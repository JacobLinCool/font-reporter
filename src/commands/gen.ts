import fs from "node:fs";
import path from "node:path";
import fontkit, { Font } from "fontkit";
import { OptionValues } from "commander";
import { Char } from "../types";
import { html_to_pdf } from "../pdf";
import html_template from "../template.html";

export default async function gen(files: string[], opt: OptionValues): Promise<void> {
    const cwd = process.cwd();

    if (files.length === 0) {
        const accepted = ["ttf", "otf", "woff", "woff2"];
        files.push(
            ...fs.readdirSync(cwd).filter((f) => accepted.includes(f.split(".").pop() || "")),
        );

        if (files.length === 0) {
            console.error(`No font found in current directory ${cwd}`);
            process.exit(1);
        }
    }

    for (let i = 0; i < files.length; i++) {
        files[i] = path.resolve(cwd, files[i]);
    }

    for (const file of files) {
        if (!fs.existsSync(file)) {
            console.error(`File ${file} not found`);
            process.exit(1);
        }
    }

    const checked = new Set<string>();
    for (const file of files) {
        const name = path.basename(file).split(".").slice(0, -1).join(".");

        if (checked.has(name)) {
            continue;
        }
        checked.add(name);

        if (opt.format === "text") {
            opt.format = "txt";
        }

        const font = fontkit.openSync(file);
        const buffer = fs.readFileSync(file);
        const format = path.extname(file).slice(1);
        const datauri = `data:font/${format};base64,${buffer.toString("base64")}`;
        const chars = parse(font);

        const out = path.resolve(
            opt.output.replace("<name>", name).replace("<format>", opt.format),
        );

        if (!fs.existsSync(path.dirname(out))) {
            fs.mkdirSync(path.dirname(out), { recursive: true });
        }

        if (opt.format === "json") {
            fs.writeFileSync(out, JSON.stringify(chars, null, opt.pretty ? 4 : 0));
        } else if (opt.format === "txt") {
            fs.writeFileSync(out, generate_text(font, chars, opt.columns));
        } else if (opt.format === "html") {
            fs.writeFileSync(
                out,
                generate_html(font, chars, format, datauri, opt.columns, opt.size, true),
            );
        } else if (opt.format === "pdf") {
            const buffer = await html_to_pdf(
                generate_html(font, chars, format, datauri, opt.columns, opt.size).replace(
                    /loading="lazy"/g,
                    "",
                ),
                opt.quiet,
            );
            fs.writeFileSync(out, buffer);
        } else {
            console.error(`Unknown format ${opt.format}`);
            process.exit(1);
        }

        if (!opt.quiet) {
            console.log(`${out} generated`);
        }
    }
}

function parse(font: Font): Char[] {
    return font.characterSet
        .map((c) => {
            const glyph = font.glyphForCodePoint(c);
            return {
                code: c,
                char: String.fromCharCode(c),
                path: glyph.path.toSVG(),
                bbox: glyph.bbox,
            };
        })
        .filter((c) => c.path.length > 0);
}

function generate_text(font: Font, chars: Char[], col = 16) {
    const rows: Char[][] = [];
    let row: Char[] = [];
    for (let i = 0; i < chars.length; i++) {
        row.push(chars[i]);
        if (i % col === col - 1) {
            rows.push(row);
            row = [];
        }
    }
    if (row.length) {
        rows.push(row);
    }

    const out: string[] = [];

    out.push(
        `### Font Report Generated by font-reporter (https://github.com/JacobLinCool/font-reporter) ###`,
    );

    out.push(
        [
            `Name       : ${font.fullName}`,
            `Version    : ${font.version}`,
            `Copyright  : ${font.copyright.replace(/\s+/g, " ")}`,
            `Characters : ${chars.length}`,
        ].join("\n"),
    );

    out.push(
        rows
            .map((row) =>
                row.map((c) => `${c.code.toString().padStart(5)} [${c.char}]`).join(" | "),
            )
            .join("\n"),
    );

    return out.join("\n\n");
}

function generate_html(
    font: Font,
    chars: Char[],
    format: string,
    datauri: string,
    col: number,
    size: number,
    interactive = false,
) {
    return html_template
        .replace(/\$name/g, font.fullName)
        .replace(/\$version/g, font.version.toString())
        .replace(/\$copyright/g, font.copyright.replace(/\s+/g, " "))
        .replace(/\$chars/, chars.length.toString())
        .replace(/\$datauri/, datauri)
        .replace(/\$format/, format)
        .replace(/\$col/g, col.toString())
        .replace(`["DATA"]`, JSON.stringify(chars))
        .replace(
            "$css",
            `body { font-family: Arial, -apple-system, sans-serif }
             .char { font-size: ${size}rem }
             .code { font-family: monospace, sans-serif }
             #text { width: 80%; display: block; margin-top: 0.5rem; padding: 0.5rem; border: 1px solid; border-radius: 0.5rem; font-size: 1.5rem }
             #text:focus { outline: none }
             #interactive { display: none ${interactive ? "" : "!important"} }
             #table { width: 100%; table-layout: fixed }
             #table * { break-inside: avoid }`,
        );
}
