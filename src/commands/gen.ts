import fs from "node:fs";
import path from "node:path";
import fontkit, { Font } from "fontkit";
import { OptionValues } from "commander";
import { Char } from "../types";
import { html_to_pdf } from "../pdf";
import html_template from "../template.html";

export default async function gen(files: string[], opt: OptionValues): Promise<void> {
    const cwd = process.cwd();

    if (files.length === 0) {
        const accepted = ["ttf", "otf", "woff", "woff2"];
        files.push(
            ...fs.readdirSync(cwd).filter((f) => accepted.includes(f.split(".").pop() || "")),
        );

        if (files.length === 0) {
            console.error(`No font found in current directory ${cwd}`);
            process.exit(1);
        }
    }

    for (let i = 0; i < files.length; i++) {
        files[i] = path.resolve(cwd, files[i]);
    }

    for (const file of files) {
        if (!fs.existsSync(file)) {
            console.error(`File ${file} not found`);
            process.exit(1);
        }
    }

    const checked = new Set<string>();
    for (const file of files) {
        const name = path.basename(file).split(".").slice(0, -1).join(".");
        const font = fontkit.openSync(file);
        const chars = parse(font);

        if (checked.has(name)) {
            continue;
        }
        checked.add(name);

        if (opt.format === "text") {
            opt.format = "txt";
        }

        const out = path.resolve(
            opt.output.replace("<name>", name).replace("<format>", opt.format),
        );

        if (opt.format === "json") {
            fs.writeFileSync(out, JSON.stringify(chars, null, opt.pretty ? 4 : 0));
        } else if (opt.format === "txt") {
            fs.writeFileSync(out, generate_text(font, chars, opt.columns));
        } else if (opt.format === "html") {
            fs.writeFileSync(out, generate_html(font, chars, opt.columns, opt.size, true));
        } else if (opt.format === "pdf") {
            const buffer = await html_to_pdf(
                generate_html(font, chars, opt.columns, opt.size).replace(/loading="lazy"/g, ""),
                opt.quiet,
            );
            fs.writeFileSync(out, buffer);
        } else {
            console.error(`Unknown format ${opt.format}`);
            process.exit(1);
        }

        if (!opt.quiet) {
            console.log(`${out} generated`);
        }
    }
}

function parse(font: Font): Char[] {
    return font.characterSet
        .map((c) => {
            const glyph = font.glyphForCodePoint(c);
            return {
                code: c,
                char: String.fromCharCode(c),
                path: glyph.path.toSVG(),
                bbox: glyph.bbox,
            };
        })
        .filter((c) => c.path.length > 0);
}

function generate_text(font: Font, chars: Char[], col = 16) {
    const rows: Char[][] = [];
    let row: Char[] = [];
    for (let i = 0; i < chars.length; i++) {
        row.push(chars[i]);
        if (i % col === col - 1) {
            rows.push(row);
            row = [];
        }
    }
    if (row.length) {
        rows.push(row);
    }

    const out: string[] = [];

    out.push(
        `### Font Report Generated by font-reporter (https://github.com/JacobLinCool/font-reporter) ###`,
    );

    out.push(
        [
            `Name       : ${font.fullName}`,
            `Version    : ${font.version}`,
            `Copyright  : ${font.copyright.replace(/\s+/g, " ")}`,
            `Characters : ${chars.length}`,
        ].join("\n"),
    );

    out.push(
        rows
            .map((row) =>
                row.map((c) => `${c.code.toString().padStart(5)} [${c.char}]`).join(" | "),
            )
            .join("\n"),
    );

    return out.join("\n\n");
}

function generate_html(font: Font, chars: Char[], col = 16, size = 2, interactive = false) {
    return html_template
        .replace(/\$name/g, font.fullName)
        .replace(/\$version/g, font.version.toString())
        .replace(/\$copyright/g, font.copyright.replace(/\s+/g, " "))
        .replace(/\$chars/, chars.length.toString())
        .replace(`["DATA"]`, JSON.stringify(chars))
        .replace(
            "$css",
            `img { width: ${size}rem; height: ${size}rem }
             input { border: 1px solid }
             input:focus { outline: none }
             #interactive { opacity: 0 }
             #table { width: 100%; display: grid; grid-template-columns: repeat(${col}, 1fr); grid-gap: 0.5rem }
             #table > div { break-inside: avoid }`,
        )
        .replace(/\$col/g, col.toString())
        .replace(
            "<!-- Interactive -->",
            interactive ? `<div id="interactive"><b>Test: </b><input /></div>` : "",
        );
}
